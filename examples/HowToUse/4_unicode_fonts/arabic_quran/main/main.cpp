#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_freertos_hooks.h"
#include "hal/spi_types.h"

#include "lgfx/v1/lgfx_fonts.hpp"

#include <esp_spiffs.h>

#define LGFX_AUTODETECT
#define LGFX_USE_V1
#include <LovyanGFX.hpp>

#include <quran_u8g2.c>

#define SPIFFS_PARTITION "data"
const char *TAG = "QURAN_EXAMPLE";

LGFX lcd;

// otf2bdf -r 72 -p 32 x.ttf -o quran.bdf
// bdfconv -v -f 1 -m "0-127,1536-1791,64336-64337,65136-65279" quran.bdf -o quran_u8g2.c -n quran_u8g2 -d quran.bdf
lgfx::U8g2font quran_font (quran_u8g2);


void init_spiffs() {
      esp_vfs_spiffs_conf_t conf = {
        .base_path = "/spiffs",
        .partition_label = SPIFFS_PARTITION,
        .max_files = 5,
        .format_if_mount_failed = false
    };

    if (esp_vfs_spiffs_register(&conf) != ESP_OK) {
        printf("Failed to mount SPIFFS partition\n");
        return;
    }

    ESP_LOGI(TAG, "SPIFFS partition mounted successfully\n");
}

std::u16string utf8_to_utf16(const std::string& utf8_str) { // Generated by ChatGPT probably optimizable
    std::u16string utf16_str; 
    size_t i = 0;
    while (i < utf8_str.size()) {
        uint32_t codepoint = 0;
        unsigned char ch = utf8_str[i];

        if (ch <= 0x7F) {
            // 1-byte sequence (ASCII)
            codepoint = ch;
            i++;
        } else if ((ch & 0xE0) == 0xC0) {
            // 2-byte sequence
            codepoint = ((utf8_str[i] & 0x1F) << 6) | (utf8_str[i + 1] & 0x3F);
            i += 2;
        } else if ((ch & 0xF0) == 0xE0) {
            // 3-byte sequence
            codepoint = ((utf8_str[i] & 0x0F) << 12) |
                        ((utf8_str[i + 1] & 0x3F) << 6) |
                        (utf8_str[i + 2] & 0x3F);
            i += 3;
        } else if ((ch & 0xF8) == 0xF0) {
            // 4-byte sequence (rare for Arabic text)
            codepoint = ((utf8_str[i] & 0x07) << 18) |
                        ((utf8_str[i + 1] & 0x3F) << 12) |
                        ((utf8_str[i + 2] & 0x3F) << 6) |
                        (utf8_str[i + 3] & 0x3F);
            i += 4;
        } else {
            // Invalid UTF-8 sequence, handle error
            ESP_LOGW(TAG, "Invalid UTF-8 sequence");
            i++;
        }

        // Convert codepoint to UTF-16
        if (codepoint <= 0xFFFF) {
            utf16_str.push_back(static_cast<char16_t>(codepoint));
        } else {
            // Surrogate pair. Ignore
            ESP_LOGW(TAG, "Ignoring surrogate pair: %lx", codepoint);
        }
    }
    return utf16_str;
}
std::u16string getRandomAyah() {
    std::u16string ayah;
    init_spiffs();

    struct timeval tv;
    gettimeofday(&tv, NULL);
    ESP_LOGW(TAG, "Seed: %li", tv.tv_usec);
    srand(tv.tv_usec);

    char surah[23];
    snprintf(surah, 23, "/spiffs/surahs/%hhu.txt", (rand() % 113) + 1);
    ESP_LOGI(TAG, "Opening file: %s", surah);
    FILE *file = fopen(surah, "r");
    if (!file) { ESP_LOGE(TAG, "Failed to open file: %s", surah); esp_vfs_spiffs_unregister(SPIFFS_PARTITION); return ayah; }

    char buffer[5120];
    if (!fgets(buffer, sizeof(buffer), file)) { ESP_LOGE(TAG, "Failed to read line count"); fclose(file); esp_vfs_spiffs_unregister(SPIFFS_PARTITION); return ayah; }

    uint16_t line_count = atoi(buffer);
    if (line_count <= 0) { ESP_LOGE(TAG, "Invalid line count"); fclose(file); esp_vfs_spiffs_unregister(SPIFFS_PARTITION); return ayah; }

    int random_line = rand() % (line_count - 1);
    ESP_LOGI(TAG, "Chose ayah number: %i", random_line);
    for (int i = 0; i < random_line; ++i) {
        if (!fgets(buffer, sizeof(buffer), file)) { ESP_LOGE(TAG, "Failed to read line %d", i + 1); fclose(file); esp_vfs_spiffs_unregister(SPIFFS_PARTITION); return ayah; }
    }

    ESP_LOGI(TAG, "Ayah, chosen successfully");

    uint16_t len = strlen(buffer);
    ESP_LOGI(TAG, "Ayah length is %i Bytes", len);

    if (buffer[len - 1] == '\n') buffer[len - 1] = '\0';
    std::string utf8_str(buffer);
    ayah = utf8_to_utf16(utf8_str);

    fclose(file);
    esp_vfs_spiffs_unregister(SPIFFS_PARTITION);

    return ayah;
}
void dislpay_ayah(std::u16string ayah) {
    uint16_t scr_width = lcd.width();

    uint8_t margin = 10;
    lgfx::FontMetrics ch_metric;
    std::vector<uint16_t> lineWidths;
    std::vector<uint16_t> letterWidths;
    lineWidths.emplace_back();
    uint16_t wordWidth = 0;
    for (auto ch : ayah) {
        quran_font.updateFontMetric(&ch_metric, ch);
        letterWidths.push_back(ch_metric.x_advance);
        
        if (ch == u' ') {
            if (lineWidths.back() + wordWidth > scr_width - margin*2) {
                ESP_LOGW(TAG, "lineWidths.back(): %i", lineWidths.back());
                lineWidths.emplace_back();
            }
            lineWidths.back() += wordWidth;
            wordWidth = 0;
        }

        wordWidth += ch_metric.x_advance;
        ESP_LOGW(TAG, "wordWidth: %i", wordWidth);
    }
    if (ayah.back() != u' ') {
        if (lineWidths.back() + wordWidth > scr_width - margin*2) {
            ESP_LOGW(TAG, "lineWidths.back(): %i", lineWidths.back());
            lineWidths.emplace_back();
        }
        lineWidths.back() += wordWidth;
    }

    uint8_t line = 0;
    uint16_t y = 60;
    int16_t endX = (scr_width - lineWidths[line])/2;
    int16_t x = scr_width - endX;
    for (uint16_t i=0; i < ayah.size(); i++) {
        if (ayah[i] == u' ') {
            if (x <= endX + 1) {
                line++;
                endX = (scr_width - lineWidths[line])/2;
                x = scr_width - endX;
                y += 60;
            }
            x -= letterWidths[i];
            continue;
        }

        lcd.drawChar(ayah[i], x - letterWidths[i], y);
        x -= letterWidths[i];
        ESP_LOGW(TAG, "char: %x, x: %i, endX: %i, letterWidth: %i", ayah[i], x, endX, letterWidths[i]);
    }

}

void app(void*) {
    lcd.init();
    lcd.setRotation(1);
    lcd.clear();
    lcd.setFont(&quran_font);
    
    while (1) {
        std::u16string ayah = getRandomAyah();
        dislpay_ayah(ayah);

        while (1) {
            uint_fast8_t t = lcd.getTouch(&t, &t);
            if (t) break;
            else vTaskDelay(pdMS_TO_TICKS(16));
        }
        
        lcd.clear();
    }
}

extern "C" void app_main(void) {
  xTaskCreate(app, "app", 8192, NULL, 1, NULL);
}



